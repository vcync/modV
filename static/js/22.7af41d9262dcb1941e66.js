webpackJsonp([22],{830:function(n,e){n.exports='/*{\n  "DESCRIPTION": "Fiddling with Abstract Corridor",\n  "CREDIT": "WilstonOreo",\n  "CATEGORIES": [\n    "tunnel",\n    "trianglenoise"\n  ],\n  "INPUTS": [\n    {\n      "NAME": "modifier",\n      "TYPE": "float",\n      "MIN": -2.0,\n      "MAX": 2.0,\n      "DEFAULT": 1.0\n    }\n  ]\n}*/\n\nvec3 iResolution = vec3(RENDERSIZE, 1.);\nfloat iTime = TIME;\n\n#define PI 3.1415926535898\n\n// Non-standard vec3-to-vec3 hash function.\nvec3 hash33(vec3 p){\n\n    float n = sin(dot(p, vec3(7, 157, 113)));\n    return fract(vec3(2097152, 262144, 32768)*n);\n}\n\n// 2x2 matrix rotation.\nmat2 rot2(float a){\n\n    float c = cos(a); float s = sin(a);\n  return mat2(c, s, -s, c);\n}\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it\'s not really being used to its full potential here.\nvec3 tri(in vec3 x){return abs(x-floor(x)-.5);} // Triangle function.\n\n\nfloat surfFunc(in vec3 p){\n\n  return dot(tri(p*0.75 + tri(p*0.4).yzx), vec3(0.5 + 0.4*clamp(3.0*sin(iTime*0.72+5.21),-1.0,1.0)));\n}\nvec2 path(in float z){ float s = sin(z/24.)*cos(z/3.); return vec2(s*12., -s*6.0); }\n\n// Standard tunnel distance function with some perturbation thrown into the mix. A floor has been\n// worked in also. A tunnel is just a tube with a smoothly shifting center as you traverse lengthwise.\n// The walls of the tube are perturbed by a pretty cheap 3D surface function.\nfloat map(vec3 p){\n\n    // Square tunnel.\n    // For a square tunnel, use the Chebyshev(?) distance: max(abs(tun.x), abs(tun.y))\n    vec2 tun = abs(p.xy - path(p.z))*vec2(0.5 + 0.1* clamp(60.0*sin(iTime*0.04),-1.0,1.0));\n    float n = 1.- max(tun.x, tun.y) + (0.6-surfFunc(p));\n    return n;\n}\n\n// Surface normal.\nvec3 getNormal(in vec3 p) {\n\n  const float eps = 0.001;\n  return normalize(vec3(\n    map(vec3(p.x+eps,p.y,p.z))-map(vec3(p.x-eps,p.y,p.z)),\n    map(vec3(p.x,p.y+eps,p.z))-map(vec3(p.x,p.y-eps,p.z)),\n    map(vec3(p.x,p.y,p.z+eps))-map(vec3(p.x,p.y,p.z-eps))\n  ));\n\n}\n\n\n// Cool curve function, by Shadertoy user, Nimitz.\n//\n// I think it\'s based on a discrete finite difference approximation to the continuous\n// Laplace differential operator? Either way, it gives you the curvature of a surface,\n// which is pretty handy.\n//\n// From an intuitive sense, the function returns a weighted difference between a surface\n// value and some surrounding values. Almost common sense... almost. :) If anyone\n// could provide links to some useful articles on the function, I\'d be greatful.\n//\n// Original usage (I think?) - Xyptonjtroz: https://www.shadertoy.com/view/4ts3z2\nfloat curve(in vec3 p, in float w){\n\n    vec2 e = vec2(-1., 1.)*w;\n\n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n\n    return 1.0/(w*w+0.004) *(t1 + t2 + t3 + t4 - 4.*map(p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  iTime = iTime * modifier;\n\n  // Screen coordinates.\n  vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\n  // Camera Setup.\n  vec3 lookAt = vec3(0.0, 0.0, iTime);  // "Look At" position.\n  vec3 camPos = lookAt + vec3(0.0, 0.1, -0.5); // Camera position, doubling as the ray origin.\n\n    // Light positioning. One is a little behind the camera, and the other is further down the tunnel.\n  vec3 light_pos = camPos + vec3(0.0, 0.125, -0.125);// Put it a bit in front of the camera.\n\n  // Using the Z-value to perturb the XY-plane.\n  // Sending the camera, "look at," and two light vectors down the tunnel. The "path" function is\n  // synchronized with the distance function. Change to "path2" to traverse the other tunnel.\n  lookAt.xy += path(lookAt.z);\n  camPos.xy += path(camPos.z);\n  light_pos.xy += path(light_pos.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = PI/3.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x ));\n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n\n    // Swiveling the camera from left to right when turning corners.\n    rd.xy *= rot2( -path(lookAt.z).x/32. );\n\n    // Standard ray marching routine. I find that some system setups don\'t like anything other than\n    // a "break" statement (by itself) to exit.\n  float t = 0.0, dt;\n  for(int i=0; i<64; i++){\n    dt = map(camPos + rd*t);\n    if( t>150.){ break; }\n    t += dt*0.75;\n  }\n\n    // The final scene color. Initated to black.\n  vec3 sceneCol = vec3(0.);\n\n  // The ray has effectively hit the surface, so light it up.\n  if(dt<0.005){\n\n      t += dt;\n\n      // Surface position and surface normal.\n      vec3 sp = t * rd+camPos;\n      vec3 sn = getNormal(sp);\n\n      // Light direction vectors.\n      vec3 ld = light_pos-sp;\n\n        // Distance from respective lights to the surface point.\n      float distlpsp = max(length(ld)*0.1, 2.0);\n\n\n      // Normalize the light direction vectors.\n      ld /= distlpsp;\n      // Light attenuation, based on the distances above.\n      float atten = min(1./(distlpsp), 1.);\n\n      // Ambient light.\n      float ambience = 0.25;\n\n      // Diffuse lighting.\n      float diff = max( dot(sn, ld), 0.0);\n\n\n      // Specular lighting.\n      float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 8.);\n\n      // Curvature.\n      float crv = clamp(curve(sp, 0.125)*0.5+0.5, .0, 1.);\n\n      // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 1., .0, 1.), 0.1);\n\n      // Darkening the crevices. Otherwise known as cheap, scientifically-incorrect shadowing.\n      float shading =  crv*0.5+0.5;\n\n      // Combining the above terms to produce the final color. It was based more on acheiving a\n        // certain aesthetic than science.\n        //\n        // Glow.\n\n        // Shading.\n\n        float gridValue = clamp(4.0*cos(iTime*0.412),-1.0,1.0);\n\n        sceneCol = atten * vec3( fre*crv*4. ) * vec3(0.1*-gridValue,0.8+0.3 * gridValue,1.0 * - gridValue);\n\n        // Drawing the lines on the walls. Comment this out and change the first texture to\n        // granite for a granite corridor effect.\n        sceneCol *= clamp((gridValue + 1.0 )*abs(curve(sp, 0.0125)) - gridValue * (1.0 - abs(curve(sp, 0.0125))), .0, 1.);\n\n\n  }\n\n  fragColor = vec4(clamp(sceneCol, 0., 1.), 1.0);\n\n}\n\nvoid main(void) {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}'}});